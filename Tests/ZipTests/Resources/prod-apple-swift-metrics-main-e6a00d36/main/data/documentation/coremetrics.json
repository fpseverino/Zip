{"hierarchy":{"paths":[[]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/coremetrics"]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"sections":[],"kind":"symbol","topicSections":[{"title":"Metric types","identifiers":["doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Counter","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Meter","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Recorder","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Timer"]},{"title":"Classes","identifiers":["doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/FloatingPointCounter","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Gauge","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MultiplexMetricsHandler","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/NOOPMetricsHandler"]},{"title":"Protocols","identifiers":["doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/CounterHandler","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/FloatingPointCounterHandler","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MeterHandler","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MetricsFactory","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/RecorderHandler","doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/TimerHandler"]},{"title":"Structures","identifiers":["doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/TimeUnit"]},{"title":"Enumerations","identifiers":["doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MetricsSystem"]}],"primaryContentSections":[{"content":[{"anchor":"Overview","level":2,"text":"Overview","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Almost all production server software needs to emit metrics information for observability. Because it’s unlikely that all parties can agree on one specific metrics backend implementation, this API is designed to establish a standard that can be implemented by various metrics libraries which then post the metrics data to backends like "},{"type":"reference","identifier":"https:\/\/prometheus.io\/","isActive":true},{"text":", ","type":"text"},{"type":"reference","identifier":"https:\/\/graphiteapp.org","isActive":true},{"type":"text","text":", publish over "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/statsd\/statsd"},{"type":"text","text":", write to disk, etc."}]},{"type":"paragraph","inlineContent":[{"text":"This is the beginning of a community-driven open-source project actively seeking contributions, be it code, documentation, or ideas. Apart from contributing to SwiftMetrics itself, we need metrics compatible libraries which send the metrics over to backend such as the ones mentioned above. What SwiftMetrics provides today is covered in the ","type":"text"},{"isActive":true,"identifier":"https:\/\/apple.github.io\/swift-metrics\/","type":"reference"},{"type":"text","text":", but it will continue to evolve with community input."}]},{"text":"Getting started","level":2,"type":"heading","anchor":"Getting-started"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you have a server-side Swift application, or maybe a cross-platform (e.g. Linux, macOS) application or library, and you would like to emit metrics, targeting this metrics API package is a great idea. Below you’ll find all you need to know to get started."}]},{"text":"Adding the dependency","level":3,"type":"heading","anchor":"Adding-the-dependency"},{"type":"paragraph","inlineContent":[{"text":"To add a dependency on the metrics API package, you need to declare it in your ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["\/\/ swift-metrics 1.x and 2.x are almost API compatible, so most clients should use",".package(url: \"https:\/\/github.com\/apple\/swift-metrics.git\", \"1.0.0\" ..< \"3.0.0\"),"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"and to your application\/library target, add “Metrics” to your dependencies:"}]},{"code":[".target(","    name: \"BestExampleApp\",","    dependencies: [","        \/\/ ...","        .product(name: \"Metrics\", package: \"swift-metrics\"),","    ]","),"],"type":"codeListing","syntax":"swift"},{"text":"Emitting metrics information","level":3,"anchor":"Emitting-metrics-information","type":"heading"},{"syntax":"swift","type":"codeListing","code":["\/\/ 1) let's import the metrics API package","import Metrics","","\/\/ 2) we need to create a concrete metric object, the label works similarly to a `DispatchQueue` label","let counter = Counter(label: \"com.example.BestExampleApp.numberOfRequests\")","","\/\/ 3) we're now ready to use it","counter.increment()"]},{"text":"Selecting a metrics backend implementation (applications only)","type":"heading","anchor":"Selecting-a-metrics-backend-implementation-applications-only","level":3},{"type":"paragraph","inlineContent":[{"text":"Note: If you are building a library, you don’t need to concern yourself with this section. It is the end users of your library (the applications) who will decide which metrics backend to use. Libraries should never change the metrics implementation as that is something owned by the application.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftMetrics only provides the metrics system API. As an application owner, you need to select a metrics backend (such as the ones mentioned above) to make the metrics information useful."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Selecting a backend is done by adding a dependency on the desired backend client implementation and invoking the "},{"code":"MetricsSystem.bootstrap","type":"codeVoice"},{"type":"text","text":" function at the beginning of the program:"}]},{"syntax":"swift","type":"codeListing","code":["MetricsSystem.bootstrap(SelectedMetricsImplementation())"]},{"inlineContent":[{"type":"text","text":"This instructs the "},{"type":"codeVoice","code":"MetricsSystem"},{"type":"text","text":" to install "},{"type":"codeVoice","code":"SelectedMetricsImplementation"},{"type":"text","text":" (actual name will differ) as the metrics backend to use."}],"type":"paragraph"},{"type":"aside","content":[{"inlineContent":[{"text":"Refer to the project’s ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-metrics","isActive":true,"type":"reference"},{"type":"text","text":" for an up-to-date list of backend implementations."}],"type":"paragraph"}],"style":"tip","name":"Tip"},{"type":"heading","anchor":"Swift-Metrics-Extras","level":3,"text":"Swift Metrics Extras"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You may also be interested in some “extra” modules which are collected in the "},{"identifier":"https:\/\/github.com\/apple\/swift-metrics-extras","isActive":true,"type":"reference"},{"text":" repository.","type":"text"}]},{"level":2,"text":"Detailed design","type":"heading","anchor":"Detailed-design"},{"text":"Architecture","type":"heading","level":3,"anchor":"Architecture"},{"type":"paragraph","inlineContent":[{"text":"We believe that for the Swift on Server ecosystem, it’s crucial to have a metrics API that can be adopted by anybody so a multitude of libraries from different parties can all provide metrics information. More concretely this means that we believe all the metrics events from all libraries should end up in the same place, be one of the backends mentioned above or wherever else the application owner may choose.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the real world, there are so many opinions over how exactly a metrics system should behave, how metrics should be aggregated and calculated, and where\/how to persist them. We think it’s not feasible to wait for one metrics package to support everything that a specific deployment needs while still being simple enough to use and remain performant. That’s why we decided to split the problem into two:"}]},{"items":[{"content":[{"inlineContent":[{"text":"a metrics API","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"a metrics backend implementation","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"This package only provides the metrics API itself, and therefore, SwiftMetrics is a “metrics API package.” SwiftMetrics can be configured (using ","type":"text"},{"type":"codeVoice","code":"MetricsSystem.bootstrap"},{"type":"text","text":") to choose any compatible metrics backend implementation. This way, packages can adopt the API, and the application can choose any compatible metrics backend implementation without requiring any changes from any of the libraries."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This API was designed with the contributors to the Swift on Server community and approved by the SSWG (Swift Server Work Group) to the “sandbox level” of the SSWG’s incubation process.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/forums.swift.org\/t\/metrics\/19353","isActive":true},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/forums.swift.org\/t\/discussion-server-metrics-api\/","isActive":true},{"type":"text","text":" |"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/forums.swift.org\/t\/feedback-server-metrics-api\/","isActive":true}]}],"kind":"content"}],"abstract":[{"type":"text","text":"A Metrics API package for Swift."}],"metadata":{"modules":[{"name":"CoreMetrics"}],"title":"CoreMetrics","externalID":"CoreMetrics","symbolKind":"module","role":"collection","roleHeading":"Framework"},"references":{"doc://CoreMetrics/documentation/CoreMetrics/RecorderHandler":{"url":"\/documentation\/coremetrics\/recorderhandler","type":"topic","role":"symbol","kind":"symbol","navigatorTitle":[{"text":"RecorderHandler","kind":"identifier"}],"abstract":[{"type":"text","text":"A "},{"code":"RecorderHandler","type":"codeVoice"},{"type":"text","text":" represents a backend implementation of a "},{"type":"codeVoice","code":"Recorder"},{"type":"text","text":"."}],"title":"RecorderHandler","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"RecorderHandler","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/RecorderHandler"},"doc://CoreMetrics/documentation/CoreMetrics/Recorder":{"type":"topic","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Recorder","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Recorder"}],"url":"\/documentation\/coremetrics\/recorder","role":"symbol","abstract":[{"text":"A recorder collects observations within a time window (usually things like response sizes) and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"can","type":"text"}]},{"type":"text","text":" provide aggregated information about the data sample, for example, count, sum, min, max and various quantiles."}],"navigatorTitle":[{"text":"Recorder","kind":"identifier"}],"kind":"symbol","title":"Recorder"},"https://github.com/apple/swift-metrics-extras":{"url":"https:\/\/github.com\/apple\/swift-metrics-extras","titleInlineContent":[{"text":"Swift Metrics Extras","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-metrics-extras","type":"link","title":"Swift Metrics Extras"},"doc://CoreMetrics/documentation/CoreMetrics/FloatingPointCounterHandler":{"url":"\/documentation\/coremetrics\/floatingpointcounterhandler","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"FloatingPointCounterHandler"},{"text":" represents a backend implementation of a ","type":"text"},{"type":"codeVoice","code":"FloatingPointCounter"},{"text":".","type":"text"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"FloatingPointCounterHandler","kind":"identifier"}],"navigatorTitle":[{"text":"FloatingPointCounterHandler","kind":"identifier"}],"title":"FloatingPointCounterHandler","type":"topic","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/FloatingPointCounterHandler","role":"symbol"},"https://apple.github.io/swift-metrics/":{"url":"https:\/\/apple.github.io\/swift-metrics\/","identifier":"https:\/\/apple.github.io\/swift-metrics\/","title":"API docs","type":"link","titleInlineContent":[{"type":"text","text":"API docs"}]},"https://forums.swift.org/t/discussion-server-metrics-api/":{"url":"https:\/\/forums.swift.org\/t\/discussion-server-metrics-api\/","titleInlineContent":[{"text":"discussion","type":"text"}],"identifier":"https:\/\/forums.swift.org\/t\/discussion-server-metrics-api\/","type":"link","title":"discussion"},"https://forums.swift.org/t/feedback-server-metrics-api/":{"titleInlineContent":[{"type":"text","text":"feedback"}],"title":"feedback","type":"link","identifier":"https:\/\/forums.swift.org\/t\/feedback-server-metrics-api\/","url":"https:\/\/forums.swift.org\/t\/feedback-server-metrics-api\/"},"doc://CoreMetrics/documentation/CoreMetrics/MetricsFactory":{"type":"topic","url":"\/documentation\/coremetrics\/metricsfactory","kind":"symbol","title":"MetricsFactory","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MetricsFactory","abstract":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"MetricsFactory"},{"text":" is the bridge between the ","type":"text"},{"code":"MetricsSystem","type":"codeVoice"},{"text":" and the metrics backend implementation.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"MetricsFactory"},{"text":"’s role is to initialize concrete implementations of the various metric types:","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"MetricsFactory","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"MetricsFactory"}],"role":"symbol"},"https://prometheus.io/":{"url":"https:\/\/prometheus.io\/","titleInlineContent":[{"text":"Prometheus","type":"text"}],"identifier":"https:\/\/prometheus.io\/","type":"link","title":"Prometheus"},"https://graphiteapp.org":{"url":"https:\/\/graphiteapp.org","identifier":"https:\/\/graphiteapp.org","title":"Graphite","type":"link","titleInlineContent":[{"text":"Graphite","type":"text"}]},"doc://CoreMetrics/documentation/CoreMetrics/MetricsSystem":{"abstract":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"MetricsSystem"},{"type":"text","text":" is a global facility where the default metrics backend implementation ("},{"code":"MetricsFactory","type":"codeVoice"},{"type":"text","text":") can be"},{"type":"text","text":" "},{"text":"configured. ","type":"text"},{"type":"codeVoice","code":"MetricsSystem"},{"type":"text","text":" is set up just once in a given program to set up the desired metrics backend"},{"type":"text","text":" "},{"type":"text","text":"implementation."}],"kind":"symbol","url":"\/documentation\/coremetrics\/metricssystem","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"MetricsSystem"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MetricsSystem","role":"symbol","navigatorTitle":[{"text":"MetricsSystem","kind":"identifier"}],"type":"topic","title":"MetricsSystem"},"doc://CoreMetrics/documentation/CoreMetrics/CounterHandler":{"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/CounterHandler","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"CounterHandler"},{"text":" represents a backend implementation of a ","type":"text"},{"type":"codeVoice","code":"Counter"},{"text":".","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"CounterHandler"}],"navigatorTitle":[{"text":"CounterHandler","kind":"identifier"}],"role":"symbol","type":"topic","kind":"symbol","title":"CounterHandler","url":"\/documentation\/coremetrics\/counterhandler"},"https://github.com/apple/swift-metrics":{"url":"https:\/\/github.com\/apple\/swift-metrics","titleInlineContent":[{"type":"text","text":"README"}],"identifier":"https:\/\/github.com\/apple\/swift-metrics","type":"link","title":"README"},"https://forums.swift.org/t/metrics/19353":{"url":"https:\/\/forums.swift.org\/t\/metrics\/19353","identifier":"https:\/\/forums.swift.org\/t\/metrics\/19353","title":"pitch","type":"link","titleInlineContent":[{"text":"pitch","type":"text"}]},"doc://CoreMetrics/documentation/CoreMetrics/Timer":{"fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"Timer","kind":"identifier"}],"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Timer","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Timer","abstract":[{"type":"text","text":"A timer collects observations within a time window (usually things like request durations) and provides aggregated information about the data sample,"},{"type":"text","text":" "},{"text":"for example, min, max and various quantiles. It is similar to a ","type":"text"},{"type":"codeVoice","code":"Recorder"},{"type":"text","text":" but specialized for values that represent durations."}],"url":"\/documentation\/coremetrics\/timer","title":"Timer","type":"topic"},"doc://CoreMetrics/documentation/CoreMetrics/MeterHandler":{"url":"\/documentation\/coremetrics\/meterhandler","role":"symbol","type":"topic","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MeterHandler","abstract":[{"type":"text","text":"A "},{"code":"MeterHandler","type":"codeVoice"},{"type":"text","text":" represents a backend implementation of a "},{"code":"Meter","type":"codeVoice"},{"text":".","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MeterHandler"}],"title":"MeterHandler","navigatorTitle":[{"text":"MeterHandler","kind":"identifier"}],"kind":"symbol"},"doc://CoreMetrics/documentation/CoreMetrics/MultiplexMetricsHandler":{"role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MultiplexMetricsHandler","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A pseudo-metrics handler that can be used to send messages to multiple other metrics handlers."}],"title":"MultiplexMetricsHandler","url":"\/documentation\/coremetrics\/multiplexmetricshandler","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/MultiplexMetricsHandler","navigatorTitle":[{"text":"MultiplexMetricsHandler","kind":"identifier"}],"kind":"symbol"},"doc://CoreMetrics/documentation/CoreMetrics/Gauge":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"Gauge","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Gauge","kind":"symbol","abstract":[{"type":"text","text":"A gauge is a metric that represents a single numerical value that can arbitrarily go up and down."},{"text":" ","type":"text"},{"type":"text","text":"Gauges are typically used for measured values like temperatures or current memory usage, but also “counts” that can go up and down, like the number of active threads."},{"type":"text","text":" "},{"text":"Gauges are modeled as ","type":"text"},{"code":"Recorder","type":"codeVoice"},{"type":"text","text":" with a sample size of 1 and that does not perform any aggregation."}],"url":"\/documentation\/coremetrics\/gauge","type":"topic","title":"Gauge","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Gauge"}]},"doc://CoreMetrics/documentation/CoreMetrics/Counter":{"kind":"symbol","abstract":[{"type":"text","text":"A counter is a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero."},{"type":"text","text":" "},{"text":"For example, you can use a counter to represent the number of requests served, tasks completed, or errors.","type":"text"}],"url":"\/documentation\/coremetrics\/counter","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"Counter","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Counter","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Counter"}],"type":"topic","title":"Counter"},"doc://CoreMetrics/documentation/CoreMetrics/TimerHandler":{"title":"TimerHandler","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"TimerHandler"},{"text":" represents a backend implementation of a ","type":"text"},{"type":"codeVoice","code":"Timer"},{"type":"text","text":"."}],"url":"\/documentation\/coremetrics\/timerhandler","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"TimerHandler"}],"kind":"symbol","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/TimerHandler","role":"symbol","navigatorTitle":[{"text":"TimerHandler","kind":"identifier"}]},"doc://CoreMetrics/documentation/CoreMetrics/FloatingPointCounter":{"url":"\/documentation\/coremetrics\/floatingpointcounter","abstract":[{"type":"text","text":"A FloatingPointCounter is a cumulative metric that represents a single monotonically increasing FloatingPointCounter whose value can only increase or be reset to zero."},{"type":"text","text":" "},{"type":"text","text":"For example, you can use a FloatingPointCounter to represent the number of requests served, tasks completed, or errors."},{"text":" ","type":"text"},{"text":"FloatingPointCounter is not supported by all metrics backends, however a default implementation is provided which accumulates floating point values and records increments to a standard Counter after crossing integer boundaries.","type":"text"}],"title":"FloatingPointCounter","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/FloatingPointCounter","navigatorTitle":[{"kind":"identifier","text":"FloatingPointCounter"}],"kind":"symbol","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"FloatingPointCounter"}],"type":"topic"},"doc://CoreMetrics/documentation/CoreMetrics":{"type":"topic","kind":"symbol","url":"\/documentation\/coremetrics","role":"collection","abstract":[{"type":"text","text":"A Metrics API package for Swift."}],"title":"CoreMetrics","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics"},"doc://CoreMetrics/documentation/CoreMetrics/Meter":{"kind":"symbol","title":"Meter","abstract":[{"type":"text","text":"A meter is similar to a gauge, it is a metric that represents a single numerical value that can arbitrarily go up and down."},{"text":" ","type":"text"},{"type":"text","text":"Meters are typically used for measured values like temperatures or current memory usage, but also “counts” that can go up and down, like the number of active threads."}],"type":"topic","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"Meter","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/Meter","navigatorTitle":[{"text":"Meter","kind":"identifier"}],"url":"\/documentation\/coremetrics\/meter","role":"symbol"},"doc://CoreMetrics/documentation/CoreMetrics/NOOPMetricsHandler":{"kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"NOOPMetricsHandler","kind":"identifier"}],"url":"\/documentation\/coremetrics\/noopmetricshandler","abstract":[{"type":"text","text":"Ships with the metrics module, used for initial bootstrapping."}],"navigatorTitle":[{"text":"NOOPMetricsHandler","kind":"identifier"}],"identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/NOOPMetricsHandler","title":"NOOPMetricsHandler","type":"topic"},"https://github.com/statsd/statsd":{"url":"https:\/\/github.com\/statsd\/statsd","titleInlineContent":[{"type":"text","text":"statsd"}],"identifier":"https:\/\/github.com\/statsd\/statsd","type":"link","title":"statsd"},"doc://CoreMetrics/documentation/CoreMetrics/TimeUnit":{"kind":"symbol","url":"\/documentation\/coremetrics\/timeunit","identifier":"doc:\/\/CoreMetrics\/documentation\/CoreMetrics\/TimeUnit","role":"symbol","abstract":[],"title":"TimeUnit","navigatorTitle":[{"kind":"identifier","text":"TimeUnit"}],"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"TimeUnit"}]}}}